#include "gcp/util/PythonGenerator.h"
#include "gcp/util/Exception.h"
#include "gcp/util/Logo.h"
#include "gcp/util/String.h"

#include<iostream>

using namespace std;

using namespace gcp::util;

/**.......................................................................
 * Constructor.
 */
PythonGenerator::PythonGenerator(std::string sourceFileName, std::string dir) : 
  dir_(dir), sourceFileName_(sourceFileName)
{
  parseFile();
}

PythonGenerator::PythonGenerator(std::string sourceFileName) : 
  dir_("."), sourceFileName_(sourceFileName)
{
  parseFile();
}

void PythonGenerator::parseFile()
{
  string s;
  ostringstream os;

  ostringstream comment;
  bool recordingComment=false;

  requiresNumpy_ = false;

  String fileParser(sourceFileName_);
  sourceFilePrefix_ = fileParser.findNextStringSeparatedByChars(".").str();

  outputPrefix_   = sourceFilePrefix_;
  outputCcSuffix_ = "cc";

  os << dir_ << "/" << sourceFileName_;

  std::ifstream inputFile(os.str().c_str());

  while(getline(inputFile, s)) {
    String str(s);

#if DIR_HAVE_NUMPY
    if(str.contains("arrayobject.h")) {
      requiresNumpy_ = true;
    }
#endif

    // If this is the start of a comment, start recording the string

    if(str.contains("SPYDOC")) {
      recordingComment = true;
    }
    
    // If this is the end comment, start recording the string

    if(str.contains("EPYDOC")) {
      recordingComment = false;
    }

    // If this is the start of a function declaration...

    if(str.contains("args") && str.contains("self")) {

      // We should not still be recording a comment if we have hit the
      // start of a function declaration

      if(recordingComment) {
	recordingComment = false;
	comment.str("");

	COUT("Encountered a SPYDOC directive with no EPYDOC directive");
      }

      if(str.findNextString().str() != "static")
	ThrowError("Function declaration must be static: " << s);

      String retVal = str.findNextString();
      String fnName = str.findNextStringSeparatedByChars(" (");

      if(retVal.str() == "PyObject*")
	functions_.push_back(fnName.str());

      procRetVals_.push_back(retVal.str());

      String commentStr = comment.str();
      commentStr.strip("*");
      commentStr.strip("//");

      comments_.push_back(commentStr.str());

      // And reset any comment that was recorded for this function

      comment.str("");
    }

    // If we are recording a comment, continue adding to the current
    // comment string

    if(recordingComment && !str.contains("SPYDOC")) {
      comment << str << "\\n";
    }
  }

  inputFile.close();
}

/**.......................................................................
 * Destructor.
 */
PythonGenerator::~PythonGenerator() {}

void PythonGenerator::outputCcFile()
{
  std::ostringstream os;
  std::ostringstream is;

  std::string prefixCopy = sourceFilePrefix_;

  os << dir_ << "/" << outputPrefix_ << "." << outputCcSuffix_; 
  is << dir_ << "/" << sourceFileName_;

  if(os.str() == is.str())
    ThrowError("Output file: " << os.str() << " will overwrite the input");

  // Open the files

  std::ofstream fout(os.str().c_str(), ios::out);
  std::ifstream fin(is.str().c_str());

  os.str("");
  std::string filePrefix = outputPrefix_;

  std::string s;
  while(getline(fin, s)) {
    fout << s << std::endl;
  }

  fin.close();

  //------------------------------------------------------------
  // Now append the generated part of the file
  //------------------------------------------------------------

  fout << "//=======================================================================" << std::endl;
  fout << "// Auto-generated by PythonGenerator from " << sourceFileName_             << std::endl;
  fout << "//"                                                                        << std::endl;
  fout << "// This file contains the definition of the PyMODINIT_FUNC() function"     << std::endl;
  fout << "// required for compilation into a dynamically loadable PYTHON module"     << std::endl;
  fout << "//=======================================================================" << std::endl << std::endl;


  // listFunction definition

  fout << "static PyObject* listFunctions(PyObject* self, PyObject* args)" << std::endl;
  fout << "{" << std::endl;
  fout << "   COUTCOLOR(std::endl << \"Functions available from this module:\" << std::endl, \"green\")" << std::endl;

  for(unsigned i=0; i < functions_.size(); i++) {
    fout << "   COUTCOLOR(\"     " << functions_[i] << "\", \"green\");" << std::endl;
  }

  fout << "   COUT(\"\");" << std::endl;
  fout << "   char c = ' ';";

  fout << "   return Py_BuildValue(\"c\", c);" << std::endl;
  fout << "}" << std::endl;

  // methods declarations

  fout << "static PyMethodDef " << outputPrefix_ << "_methods[] = {"    << std::endl;

  fout << "  {\"list\", listFunctions" << ", METH_VARARGS, \"Call " << outputPrefix_ 
       << ".list() for a list of functions available from this module.\"}," << std::endl;

  gcp::util::XtermManip xt;

  for(unsigned i=0; i < functions_.size(); i++) {

    bool commentIsNull = (comments_[i].size() == 1 && comments_[i][0] == '\0');

    fout << "  {\"" << functions_[i] << "\", " << functions_[i] << ", METH_VARARGS, " 
	 << "\""; 
    
    if(!commentIsNull)
      fout << comments_[i]; 
    
    fout << "\"}," << std::endl;
  }

  fout << "  {NULL, NULL, 0, NULL}"  << std::endl;
  fout << "};"  << std::endl << std::endl;

  fout << "PyMODINIT_FUNC"  << std::endl;
  fout << "init" << outputPrefix_ << "(void)" << std::endl;
  fout << "{" << std::endl;
  if (print_info_on_import)
    {
      fout << "   COUTCOLOR(std::endl << \"Type " << outputPrefix_ 
  	   << ".list() for a list of functions available from this module\" << std::endl, \"green\");" << std::endl;
    }
  fout << "  (void) Py_InitModule(\"" << outputPrefix_ << "\", " << outputPrefix_ << "_methods);" << std::endl;

  // numpy requires the array module to be imported before any PyArray
  // calls are made

  if(requiresNumpy_) {
    fout << " import_array();" << std::endl;
  }

#if 0
  fout << "Logo logo;" << std::endl;
  fout << "logo.display();" << std::endl;
#endif

  fout << "}" << std::endl;

  fout.close();
}

std::string PythonGenerator::caps(std::string inp)
{
  std::string outp = inp;

  for(unsigned i=0; i < outp.size(); i++)
    outp[i] = toupper(outp[i]);

  return outp;
}

void PythonGenerator::setOutputPrefix(std::string prefix)
{
  outputPrefix_ = prefix;
}

void PythonGenerator::setOutputCcSuffix(std::string suffix)
{
  outputCcSuffix_ = suffix;
}
